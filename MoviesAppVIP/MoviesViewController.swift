//
//  MoviesViewController.swift
//  MoviesAppVIP
//
//  Created by Kamil Zajac on 17.06.2017.
//  Copyright (c) 2017 Kamil Zajac. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol MoviesViewControllerInput
{
    func displayMovies(viewModel: Movies.Download.ViewModel.Success)
    func displayError(viewModel: Movies.Download.ViewModel.Error)
}

protocol MoviesViewControllerOutput
{
    func startDownloadMovies(request: Movies.Download.Request)
}

class MoviesViewController: UIViewController, MoviesViewControllerInput
{
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var previousLbl: UIButton!
    @IBOutlet weak var nextLbl: UIButton!
    @IBOutlet weak var pageLbl: UILabel!
    
    var output: MoviesViewControllerOutput!
    var router: MoviesRouter!
    var movies: [Movies.Download.Response.Details] = []
    var page = 1
    var currentType = "popular"
    
    // MARK: - Object lifecycle
    
    override func awakeFromNib()
    {
        super.awakeFromNib()
        MoviesConfigurator.sharedInstance.configure(viewController: self)
    }
    
    // MARK: - View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        loadMovies()
    }
    
    // MARK: - Event handling
    
    func loadMovies()
    {
        // NOTE: Ask the Interactor to do some work
        let request = Movies.Download.Request(movieType: currentType, page: page)
        output.startDownloadMovies(request: request)
    }
    
    // MARK: - Display logic
    
    func displayMovies(viewModel: Movies.Download.ViewModel.Success)
    {
        movies = viewModel.movies
        tableView.reloadData()
    }
    
    func displayError(viewModel: Movies.Download.ViewModel.Error) {
        present(viewModel.alert, animated: true, completion: nil)
    }
    
    private func updateMoviesAndLabelsWith(type: String) {
        page = 1
        pageLbl.text = "Page \(page)"
        let request = Movies.Download.Request(movieType: type, page: page)
        output.startDownloadMovies(request: request)
        currentType = type
    }
    
    @IBAction func popularPressed(_ sender: UIBarButtonItem) {
        updateMoviesAndLabelsWith(type: "popular")
    }
    
    @IBAction func topRatedPressed(_ sender: UIBarButtonItem) {
        updateMoviesAndLabelsWith(type: "top_rated")
    }
    
    @IBAction func upcomingPressed(_ sender: UIBarButtonItem) {
        updateMoviesAndLabelsWith(type: "upcoming")
    }
    
    @IBAction func nowPlayingPressed(_ sender: UIBarButtonItem) {
        updateMoviesAndLabelsWith(type: "now_playing")
    }
    
    @IBAction func nextPagePressed(_ sender: UIButton) {
        page += 1
        if page > 1 { previousLbl.alpha = 1 }
        pageLbl.text = "Page \(page)"
        let request = Movies.Download.Request(movieType: currentType, page: page)
        output.startDownloadMovies(request: request)
    }
    
    @IBAction func previousPagePressed(_ sender: UIButton) {
        page -= 1
        if page <= 1 { previousLbl.alpha = 0 }
        pageLbl.text = "Page \(page)"
        let request = Movies.Download.Request(movieType: currentType, page: page)
        output.startDownloadMovies(request: request)
    }
    
}

extension MoviesViewController: UITableViewDelegate, UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return movies.count
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        if let cell = tableView.dequeueReusableCell(withIdentifier: "MoviesCell") as? MoviesCell {
            let movie = movies[indexPath.row]
            cell.configureCellWith(movie)
            return cell
        }
        return UITableViewCell()
    }
}












